# Лабораторная работа №6. Простое развертывание EC2 и S3 на AWS с Terraform

**Студент:** Богданов Юрий  
**Группа:** I2302  
**Преподаватель:** Калин Николай

**Дата:** 19.11.2025

---

## Цель работы

Научиться создавать базовую инфраструктуру на `AWS` с помощью `Terraform`, включая виртуальную машину (`EC2`) и `S3-бакет`, используя переменные и выходные данные, а также безопасно хранить состояние в `S3`.

---

## Предварительные требования

1. Установленый `Terraform` (версия >= 1.0).
2. Аккаунт AWS с настроенными учетными данными (AWS Access Key и Secret Key, переданные через переменные окружения или AWS CLI).
3. Базовые знания команд `Terraform` (`init`, `plan`, `apply`, `destroy`).

---

## Ход выполнения работы

### Шаг 1. Создание конфигурации `Terraform`

Перед началом выполнения шагов необходимо убедиться, что `Terraform` и `AWS CLI` установлены и корректно работают.

Нужно выполнить команды:

```bash
terraform -version
aws --version
```

![image](https://i.imgur.com/AzTXuK3.png)

Для начала работы необходимо подготовить структуру проекта, в которой будут располагаться все конфигурационные файлы `Terraform`.

#### Создание директории проекта

Необходимо перейти в рабочий каталог и создать папку для лабораторной работы:

```bash
mkdir lab6
cd lab6
```

В данном каталоге будут храниться все файлы конфигурации.
Структура после создания директории:

#### Создание конфигурационных файлов

Внутри директории требуется создать три файла:

- `main.tf` — основной файл конфигурации ресурсов;
- `variables.tf` — файл входных переменных;
- `outputs.tf` — файл выходных данных.

Файлы могут быть созданы через терминал:

```bash
touch main.tf variables.tf outputs.tf
```

или с использованием редактора VS Code.

![image](https://i.imgur.com/8j8PYor.png)

#### Настройка провайдера AWS

Для работы `Terraform` с облаком AWS необходимо указать провайдера.

В файле `main.tf` следует добавить блоки:

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}
```

Этот блок определяет настройки Terraform и подключаемого провайдера AWS. В секции `required_providers` задаётся источник и версия провайдера, обеспечивая использование совместимой и актуальной версии модуля. Блок `provider "aws"` указывает регион, в котором будут развертываться ресурсы, при этом значение берётся из переменной `aws_region`. Такой подход позволяет централизованно управлять регионом и упрощает перенос конфигурации между окружениями.

![image](https://i.imgur.com/otUHedN.png)

Этот шаг завершает базовую подготовку проекта.

### Шаг 2. Развертывание EC2-инстанса

На данном этапе необходимо добавить в конфигурацию `Terraform` описание виртуальной машины (EC2-инстанса), которая будет развернута в облаке AWS.

#### Добавление EC2-ресурса

В файл `main.tf` следует добавить ресурс `aws_instance`, определяющий создаваемый сервер. Указывается образ операционной системы Amazon Linux 2, актуальный для региона **eu-central-1**, а также тип инстанса.

В лабораторной работе используется тип `t3.micro`, доступный в Free Tier.

```hcl
resource "aws_instance" "web" {
  ami           = "ami-0b418580298265d5c"
  instance_type = "t3.micro"

  tags = {
    Name = "WebServer-${var.env}"
  }
}
```

- **`ami`** — идентификатор образа Amazon Linux 2 в регионе `eu-central-1`.
- **`instance_type`** — определяет конфигурацию виртуальной машины; тип `t3.micro` обеспечивает минимальную стоимость и доступен в Free Tier.
- **`tags`** — формирует имя ресурса, автоматически добавляя значение переменной окружения (`env`).

![image](https://i.imgur.com/78c2EWL.png)

Данный шаг завершает конфигурацию EC2-инстанса, который будет создан при запуске `terraform apply`.

### Шаг 3. Создание S3-бакета

На данном этапе необходимо добавить в инфраструктурную конфигурацию Terraform ресурс для создания S3-бакета. Бакет будет использоваться как элемент хранилища данных и должен иметь уникальное имя, включающее название окружения.

#### Добавление ресурса S3

В файл `main.tf` добавляется ресурс `aws_s3_bucket`, содержащий параметры создаваемого бакета. Имя формируется с использованием переменной `env`, что позволяет создавать разные бакеты для различных окружений.

```hcl
resource "aws_s3_bucket" "storage" {
  bucket = "bogdanov-i2302-lab6-${var.env}"
  acl    = "private"

  tags = {
    Name        = "lab6-bucket-${var.env}"
    Environment = var.env
  }
}
```

- **`bucket`** — задаёт уникальное имя бакета, в которое автоматически подставляется значение переменной окружения.
- **`acl = "private"`** — устанавливает приватный доступ к бакету, ограничивая доступ только владельцу.
- **`tags`** — используются для удобства идентификации ресурсов в AWS Management Console.

![image](https://i.imgur.com/cp9oWdA.png)

### Шаг 4. Настройка переменных

Для управления параметрами конфигурации `Terraform` необходимо использовать входные переменные, размещённые в отдельном файле `variables.tf`. Такой подход позволяет гибко изменять регион развертывания и тип окружения без изменения основного конфигурационного файла `main.tf`.

#### Определение переменных в `variables.tf`

В файле `variables.tf` нужно определить две входные переменные, которые будут использоваться в конфигурации `Terraform`:

- **`aws_region`** — переменная, определяющая регион AWS, в котором будут создаваться ресурсы. Тип переменной — `string`. Значением по умолчанию установлен регион `eu-central-1`. Использование переменной позволяет легко изменять регион без корректировки основного файла конфигурации.

- **`env`** — переменная, задающая название окружения, например `dev`, `test`, `stage` или `prod`. Это значение применяется при формировании имён ресурсов, что обеспечивает удобство разделения инфраструктуры по окружениям. Тип переменной — `string`, значение по умолчанию — `dev`.

Определение переменных упрощает управление конфигурацией, повышает гибкость `Terraform`-кода и позволяет переиспользовать проект для разных окружений с минимальными изменениями.

Содержимое файла:

```hcl
variable "aws_region" {
  description = "AWS region for resources"
  type        = string
  default     = "eu-central-1"
}

variable "env" {
  description = "Environment name (e.g. dev, prod)"
  type        = string
  default     = "dev"
}
```

![image](https://i.imgur.com/Z6Pnapj.png)

Определение переменных делает конфигурацию более гибкой и позволяет переиспользовать проект для различных окружений.

#### Создание файла `terraform.tfvars`

Для задания значений переменных надо создать файл `terraform.tfvars`. Значения из этого файла автоматически подставляются при выполнении команд `Terraform`.

Содержимое файла:

```hcl
aws_region = "eu-central-1"
env        = "dev"
```

![image](https://i.imgur.com/vdJ7AS2.png)

Таким образом, ресурсы Terraform будут развернуты в регионе **eu-central-1**, а окружение будет использоваться как **dev**.

### Шаг 5. Настройка выходных данных

Для удобства получения информации о созданных ресурсах `Terraform` использует механизм выходных данных. Выходные параметры позволяют быстро просмотреть ключевые сведения, например публичный IP-адрес EC2-инстанса или имя созданного S3-бакета, без необходимости открывать консоль AWS.

#### Добавление выходных данных

В файл `outputs.tf` необходимо добавить два выхода:

- публичный IP-адрес EC2-инстанса;
- имя созданного S3-бакета.

Каждый выходной параметр (`output`) позволяет удобно получать важную информацию о созданных ресурсах после выполнения `terraform apply`. Terraform автоматически выводит эти значения в консоль и делает доступными через команду `terraform output`.

* **`ec2_public_ip`** — выводит публичный IP-адрес развернутой виртуальной машины EC2. Это позволяет быстро узнать адрес сервера, не открывая AWS Console.

* **`s3_bucket_name`** — возвращает имя созданного S3-бакета. Значение берётся из атрибута `bucket` ресурса `aws_s3_bucket.storage`.

Такая структура выходных данных упрощает доступ к наиболее важным параметрам инфраструктуры и делает Terraform-конфигурацию более удобной и понятной при дальнейшем использовании.

Содержимое файла:

```hcl
output "ec2_public_ip" {
  description = "Public IP address of the EC2 instance"
  value       = aws_instance.web.public_ip
}

output "s3_bucket_name" {
  description = "Name of the created S3 bucket"
  value       = aws_s3_bucket.storage.bucket
}
```

![image](https://i.imgur.com/DdQV9Zm.png)

Определённые выходные параметры предоставляют удобный способ получить важную информацию о созданных ресурсах без необходимости вручную просматривать AWS Console. Это улучшает читаемость и управляемость инфраструктуры, особенно при работе с несколькими окружениями.

### Шаг 6. Настройка удалённого хранения состояния `Terraform` (Remote Backend)

Для обеспечения безопасного и централизованного хранения состояния Terraform необходимо вынести файл `terraform.tfstate` в удалённое хранилище. В данной лабораторной работе в качестве backend нужно использовать сервис **Amazon S3**, который позволяет хранить состояние инфраструктуры надёжно, с шифрованием и контролем доступа.

Использование удалённого состояния позволяет:

- избежать утери или порчи локального state-файла;
- обеспечить совместную работу нескольких пользователей;
- предотвратить конфликты при одновременном применении изменений.

#### Создание S3-бакета для хранения состояния

Прежде чем настраивать backend, необходимо вручную создать отдельный S3-бакет, который будет использоваться **только для хранения `terraform.tfstate`**.

Для создания бакета необходимо перейти в сервис **Amazon S3** и выполнить настройки:

- Регион: `eu-central-1`
- Имя бакета: `bogdanov-i2302-lab6-tfstate`
- ACL: отключены (рекомендуется AWS)
- Public access: полностью заблокирован
- Шифрование: включено (`SSE-S3`)

Это обеспечит безопасность и корректную работу Terraform backend.

![image](https://i.imgur.com/6afWYjP.png)

После подтверждения бакет создаётся и отображается в списке:

![image](https://i.imgur.com/ixcoVqL.png)

#### Настройка backend в файле `main.tf`

После создания бакета необходимо настроить Terraform так, чтобы состояние автоматически сохранялось в S3. Для этого в блок `terraform` добавляется конфигурация backend:

```hcl
terraform {
  backend "s3" {
    bucket  = "bogdanov-i2302-lab6-tfstate"
    key     = "lab6/terraform.tfstate"
    region  = "eu-central-1"
    encrypt = true
  }

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}
```

- **`bucket`** — имя ранее созданного S3-бакета.
- **`key`** — путь и имя файла состояния внутри бакета (позволяет структурировать state для разных проектов).
- **`region`** — регион, в котором создан бакет.
- **`encrypt = true`** — включает серверное шифрование файла состояния на стороне S3.

Такая конфигурация обеспечивает безопасное хранение state-файла и предотвращает утечку чувствительной информации.

![image](https://i.imgur.com/MQv2RTn.png)

#### Настройка `.gitignore`

Так как состояние теперь хранится в S3, локальные файлы состояния должны быть исключены из репозитория.

Файл `.gitignore` должен содержать следующие строки:

```text
.terraform/
.terraform.lock.hcl
terraform.tfstate
terraform.tfstate.backup
```

Это исключает из репозитория:

- локальные служебные файлы Terraform,
- локальный state-файл,
- резервную копию state.

![image](https://i.imgur.com/hpAnhuK.png)

В результате выполнения данного этапа инфраструктура использует удалённый backend в S3, обеспечивая:

- безопасное хранение состояния,
- шифрование данных,
- отсутствие state-файлов в Git-репозитории,
- стабильность и совместимость при работе над проектом.

### Шаг 7. Выполнение и проверка `Terraform`-конфигурации

После завершения настройки backend, провайдера и всех ресурсов нужно проивести развёртку инфраструктуры с помощью стандартной последовательности команд `Terraform`.

#### Инициализация проекта (`terraform init`)

Команда:

```bash
terraform init
```

Выполняет загрузку провайдера AWS и подключение backend S3.

![image](https://i.imgur.com/5J2Rrtk.png)

Инициализация прошла успешно — `Terraform` создал файл блокировки версий `.terraform.lock.hcl` и подтвердил использование backend `"s3"`.

#### Просмотр плана создания инфраструктуры (`terraform plan`)

Команда:

```bash
terraform plan
```

Показывает, что `Terraform` собирается создать два ресурса:

- EC2-инстанс (`aws_instance.web`)
- S3-бакет (`aws_s3_bucket.storage`)

Также будет сформирован список ожидаемых атрибутов и выходных значений.

![image](https://i.imgur.com/bOrGr6w.png)

#### Применение изменений (`terraform apply`)

Команда:

```bash
terraform apply
```

После подтверждения (`yes`) `Terraform` успешно создаёт ресурсы.

В логах видно:

- S3 бакет создан за ~3 секунды;
- EC2-инстанс — за ~16 секунд.

Terraform вывел секцию `Outputs`:

- **ec2_public_ip** — публичный IP созданного инстанса
- **s3_bucket_name** — имя созданного бакета

![image](https://i.imgur.com/dh0kurH.png)

#### Проверка созданных ресурсов в AWS Console

В панели AWS подтверждены:

- **EC2-инстанс** в состоянии *Running*
  – название: *WebServer-dev*
  – тип: *t3.micro*
  – отображается публичный IP, совпадающий с `terraform output`

![image](https://i.imgur.com/43IDsAu.png)

- **S3-бакет**
  – *bogdanov-i2302-lab6-dev* создан автоматически `Terraform`
  – *bogdanov-i2302-lab6-tfstate* используется для хранения состояния

![image](https://i.imgur.com/efgw5zr.png)

#### Проверка удалённого состояния `Terraform`

В S3-бакете `bogdanov-i2302-lab6-tfstate` был обнаружен файл состояния:

```
lab6/terraform.tfstate
```

![image](https://i.imgur.com/bvoKx7f.png)

Это подтверждает, что backend настроен корректно, и `Terraform` хранит состояние удалённо на стороне AWS.

### Шаг 8. Очистка ресурсов инфраструктуры

После проверки работы развёрнутой инфраструктуры необходимо корректно освободить использованные ресурсы AWS, чтобы не расходовать квоту и средства. Для этого используется команда `terraform destroy`, которая удаляет все объекты, описанные в конфигурации.

#### Удаление ресурсов через `Terraform`

В каталоге проекта нужно выполнить команду:

```bash
terraform destroy
```

`Terraform` считал текущее состояние из backend’а и сгенерировал план уничтожения ресурсов:

- ресурс `aws_instance.web` — EC2-инстанс `WebServer-dev`;
- ресурс `aws_s3_bucket.storage` — S3-бакет `bogdanov-i2302-lab6-dev`.

Перед выполнением команда запросит подтверждение (строка *“Do you really want to destroy all resources?”*).

После ввода `yes` `Terraform` последовательно удалит оба ресурса:

```text
Destroy complete! Resources: 2 destroyed.
```

![image](https://i.imgur.com/5U8OqWb.png)
![image](https://i.imgur.com/fZctNQC.png)
![image](https://i.imgur.com/hzRmXSo.png)

#### Проверка удаления в AWS Console

Для контроля результата нужно выполнить проверку в консоли AWS:

- в разделе **EC2** инстанс `WebServer-dev` отображается в состоянии **Terminated**;

![image](https://i.imgur.com/8KNVNnQ.png)

- в разделе **S3** бакет `bogdanov-i2302-lab6-dev` отсутствует, при этом бакет `bogdanov-i2302-lab6-tfstate` сохранён, так как используется для хранения удалённого состояния Terraform.

![image](https://i.imgur.com/gHt9mUH.png)

Таким образом, все созданные в ходе лабораторной работы ресурсы (EC2-инстанс и S3-бакет окружения `dev`) были корректно удалены с помощью `terraform destroy`, а инфраструктура приведена в исходное состояние без лишних затрат.

---

## Вывод

В ходе лабораторной работы была полностью реализована автоматизация развёртывания инфраструктуры с помощью `Terraform`. Последовательно были созданы конфигурационные файлы, настроен backend в S3, выполнено развёртывание EC2-инстанса и S3-бакета, а затем проведена проверка их корректной работы в AWS Console. В процессе были использованы переменные, выходные значения, теги, а также настройки удалённого хранения состояния, что позволило получить практический опыт инфраструктуры как кода и понять, как `Terraform` управляет ресурсами через декларативный подход. После тестирования инфраструктуры была выполнена её полная очистка командой `terraform destroy`, благодаря чему ресурсы были корректно удалены, а затраты — исключены. Работа продемонстрировала весь цикл жизненного управления инфраструктурой, от проектирования до удаления, и показала удобство и надёжность автоматизированного подхода к работе с AWS.
