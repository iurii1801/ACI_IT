# Лабораторная работа №2

**Студент:** Богданов Юрий  
**Группа:** I2302  
**Преподаватель:** Калин Николай

**Дата:** 03.10.2025

---

## Цель работы

Целью лабораторной работы является освоение основ написания и выполнения Bash-скриптов в Linux, включая работу с переменными, вводом и выводом данных, условиями, циклами и системными утилитами, а также получение практических навыков автоматизации рутинных задач, таких как взаимодействие с пользователем, резервное копирование и мониторинг состояния файловой системы.

---

## Ход выполнения работы

### Задание 1

### «CLI‑ассистент: приветствие, валидация и мини‑отчёт о системе»

**Цель**

Освоить ввод/вывод, переменные, условия, простые циклы, подстановку команд.

### Что сделать

Написать скрипт `cli_assistant.sh`, который:

1. Спрашивает имя пользователя и (необязательно) его отдел/группу
2. Валидирует ввод (пустые значения — повторный запрос до 3 попыток).
3. Выводит мини‑отчёт:
    - текущая дата,
    - имя хоста,
    - время аптайма,
    - свободное место на `/`,
    - количество пользователей, вошедших в систему.
4. Итоговая строка: «Здравствуйте, <Имя> (<Отдел|не указан>)!».

### Требования

- Shebang `#!/bin/bash`.
- Валидация пустого ввода с максимум 3 попытками (после — вежливый выход с кодом `1`).
- Использование командной подстановки `$(...)`.
- Только стандартные утилиты.

---

### Создание скрипта `cli_assistant.sh`

В домашней директории Ubuntu был создан новый файл `cli_assistant.sh` с помощью текстового редактора `nano`:

```bash
nano cli_assistant.sh
```

В файл был добавлен код, реализующий ввод имени и отдела, валидацию и вывод системной информации.

![image](https://i.imgur.com/fC8Rx6U.png)
![image](https://i.imgur.com/1lkwv5H.png)

В начале скрипта используется цикл `while`, который трижды запрашивает у пользователя имя. Если строка пустая, выводится сообщение с просьбой повторить ввод. После трёх неудачных попыток программа завершается с кодом `1`.

Далее идёт необязательный ввод отдела/группы. Если пользователь ничего не ввёл, переменной присваивается значение «не указан».

С помощью командной подстановки `$(...)` получаются системные данные:

- `date` — текущая дата и время;
- `hostname` — имя хоста;
- `uptime -p` — аптайм системы в удобочитаемом виде;
- `df -h /` и `awk` — свободное место на корневом разделе;
- `who | wc -l` — количество пользователей в системе.

В конце выводится мини-отчёт и приветственное сообщение с именем и отделом пользователя.

### Подготовка к запуску

После написания скрипта ему были выданы права на исполнение:

```bash
chmod +x cli_assistant.sh
```

### Запуск и проверка работы

Скрипт был запущен командой:

```bash
./cli_assistant.sh
```

При запуске отображается пошаговый ввод данных. В случае пустого имени выводится сообщение с предложением повторить ввод. После успешного ввода отображается мини-отчёт о системе и приветствие пользователя.

**Пример работы программы:**

![image](https://i.imgur.com/550SQXl.png)

Работа программы прошла успешно, ошибок не возникло.

---

### Задание 2

### «Резервное копирование каталога с логированием и ротацией»

**Цель**

Отработать аргументы скрипта, работу с файлами/путями, условия, архивирование, коды возврата и логирование.

### Что сделать

Написать скрипт `backup_rot.sh`, который:

- Принимает аргументы:
    1. Обязательный путь к каталогу‑источнику (например, `/home/student/data`).
    2. Необязательный путь к каталогу для бэкапов (по умолчанию `~/backups`).
  
- Проверяет, что источник существует и это каталог; создаёт каталог бэкапов при необходимости.
- Создаёт архив `tar.gz` с именем по шаблону:  
    `backup_<basename источника>_<YYYYMMDD_HHMMSS>.tar.gz`
- Пишет лог в `backup.log` в каталоге бэкапов (время, имя архива, размер, код возврата).
- Возвращает код `0` при успехе, `≠0` при ошибках ввода/архивации.

### Примеры

```shell
$ ./backup_rot.sh 
~/projects/app 
$ ./backup_rot.sh /var/www /mnt/storage/backups 5
```

### Требования

- Защита от пробелов в путях (кавычки при `tar`, `mv`, `rm`).
- Проверка доступности записи в каталог бэкапов.

### Пример лога (фрагмент)

```shell
2025-08-23T14:45:12 SRC=/var/www DST=/mnt/storage/backups \ FILE=backup_www_20250823_144512.tar.gz SIZE=128M STATUS=0`
```

---

### Создание скрипта `backup_rot.sh`

В домашней директории был создан файл `backup_rot.sh` с помощью команды:

```bash
nano backup_rot.sh
```

В скрипте реализована логика резервного копирования каталога с проверками и логированием.
Он принимает один обязательный аргумент — путь к исходной директории, и один необязательный — путь к каталогу для хранения бэкапов (по умолчанию `~/backups`).

![image](https://i.imgur.com/shgSyDQ.png)
![image](https://i.imgur.com/hWg8amp.png)
![image](https://i.imgur.com/CJ2VqiT.png)

Скрипт принимает путь к каталогу-источнику, а также опционально — путь для хранения бэкапов и количество сохраняемых архивов.
Сначала проверяется, что источник существует, затем создаётся каталог для бэкапов и тестируется возможность записи с помощью временного файла.

Далее формируется имя архива по шаблону backup_<имя>_<дата>.tar.gz, и с помощью команды tar создаётся архив, учитывая возможные пробелы в путях. После успешного создания определяется его размер.

Затем в файл backup.log записываются дата, пути, имя архива, его размер и статус выполнения. В конце выполняется ротация — с помощью сортировки и tail удаляются старые архивы, чтобы сохранялось только заданное количество.

Таким образом, скрипт обеспечивает автоматическое резервное копирование с проверками, логированием и очисткой старых архивов.

### Выдача прав на выполнение и тестирование с реальной директорией

Скрипту были выданы права на исполнение:

```bash
chmod +x backup_rot.sh
```

![image](https://i.imgur.com/kl26tV6.png)

### Проверка созданных архивов и лога

Для тестирования был создан каталог с двумя текстовыми файлами:

```bash
mkdir -p ~/test_backup && echo "hello" > ~/test_backup/file1.txt && echo "world" > ~/test_backup/file2.txt
```

После этого скрипт был запущен:

```bash
./backup_rot.sh ~/test_backup
```

После выполнения в каталоге `~/backups` появляется архив с именем, сформированным по шаблону `backup_<имя>_<дата>.tar.gz`, а также файл лога `backup.log`.

Команда:

```bash
ls -lh ~/backups
```

Показывает список файлов и размер созданного архива.

Команда:

```bash
cat ~/backups/backup.log
```

Выводит записи лога, где фиксируются дата, исходный и целевой пути, имя файла, его размер и статус выполнения.

![image](https://i.imgur.com/r1bearj.png)

В логе видно, что архивирование тестовой директории завершилось успешно со статусом 0.

---

### Задание 3

## «Мониторинг дискового пространства»

**Цель**

Закрепить циклы, условия, работу с системными командами (`df`, `awk`), аргументы и коды возврата.

### Что нужно сделать

Написать скрипт `disk_monitor.sh`, который:

1. Принимает аргументы:
    - путь к файловой системе (например, `/` или `/home`),
    - необязательный порог заполнения (%) — по умолчанию 80.
2. Проверяет, что путь существует.
3. С помощью `df -h` получает процент использования.
4. Выводит:
    - текущую дату/время,
    - путь и процент занятости,
    - сообщение «OK» если меньше порога, иначе «WARNING: диск почти заполнен!».
5. Возвращает код:
    - `0`, если всё в норме,
    - `1`, если превышен порог,
    - `2`, если ошибка (например, путь не найден).

```shell
$ ./disk_monitor.sh / 75
2025-08-23 14:55:12
Путь: /
Использовано: 42%
Статус: OK
```

---

### Создание скрипта `disk_monitor.sh`

В домашней директории был создан новый файл `disk_monitor.sh`:

```bash
nano disk_monitor.sh
```

В него был добавлен код, который принимает путь к файловой системе и опционально порог заполнения (по умолчанию 80%). Скрипт проверяет существование пути, получает процент использования через `df` и `awk`, сравнивает его с порогом и выводит статус:

![image](https://i.imgur.com/fNvVvLC.png)

Скрипт принимает путь к файловой системе и опционально порог заполнения.
Сначала проверяется, существует ли указанный путь — при ошибке выводится сообщение и код `2`.

Затем с помощью `df -P` и `awk` определяется процент использования диска.
Полученные данные выводятся вместе с текущей датой, проверяемым путём и процентом занятости.

Если использование меньше заданного порога, выводится статус `OK` и скрипт завершается с кодом `0`.
Если значение превышает порог — выводится предупреждение и код `1`.

Таким образом, скрипт позволяет быстро контролировать заполненность файловых систем и может использоваться в автоматизированных проверках.

### Выдача прав и запуск проверки

Скрипту были выданы права на выполнение:

```bash
chmod +x disk_monitor.sh
```

Затем был выполнен запуск с параметрами по умолчанию и с указанием собственного порога:

```bash
./disk_monitor.sh /
./disk_monitor.sh /home 75
```

![image](https://i.imgur.com/C8s31Pu.png)

В обоих случаях программа вывела:

- текущую дату и время;
- проверяемый путь;
- процент заполнения;
- статус.

Так как процент использования диска составлял 37 %, при порогах 80 % и 75 % скрипт вернул статус `OK` и код возврата `0`.

Программа корректно отрабатывает все проверки и соответствует требованиям задания.

---

## Вывод

В ходе выполнения лабораторной работы были разработаны и протестированы три Bash-скрипта, демонстрирующие практическое применение базовых возможностей командной оболочки Linux.

Первый скрипт реализует CLI-ассистента с вводом данных, валидацией и выводом системной информации. Второй выполняет резервное копирование каталогов с проверками, логированием и ротацией архивов. Третий предназначен для мониторинга дискового пространства с выводом статуса и кодов возврата.

Все скрипты были проверены в терминале Ubuntu и корректно выполняют поставленные задачи. В результате работы были закреплены навыки работы с переменными, условиями, циклами, командной подстановкой, системными утилитами и аргументами командной строки, а также получен практический опыт автоматизации типовых задач администрирования.
